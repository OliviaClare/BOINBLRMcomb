#'
#' Generate operating characteristics for drug combination trials
#'
#' Obtain the operating characteristics of the BOIN-CombP design for drug combination
#'  trials. The BOIN-CombP design is to find a MTD within specified drug combinations in the dose matrix.
#'
#' @usage get.oc.combP(target, p.true, ncohort, cohortsize, preferred.doses, n.earlystop=NULL, startdose=c(1, 1),
#'                    titration=FALSE,p.saf=0.6*target, p.tox=1.4*target, cutoff.eli=0.95, explore_deescalation = FALSE,
#'                    extrasafe=FALSE,offset=0.05, ntrial=1000, mtd.contour=FALSE,
#'                    boundMTD=FALSE, seed=6)
#'
#' @param target the target DLT rate
#' @param p.true a \code{J*K} matrix \code{(J<=K)} containing the true toxicity probabilities of
#'               combinations with \code{J} dose levels of agent A and \code{K} dose levels of agent B
#' @param ncohort a \code{1*J} vector specifying the number of cohorts for each of \code{J} subtrials
#'                if \code{mtd.contour=TRUE}; Otherwise, a scalar specifying the total number of cohorts for
#'                the trial.
#' @param cohortsize the cohort size
#' @param preferred.doses the matrix that specifies the preference of each dose combination: 1 for preferred; 0 for less preferred; -1 for excluded.
#' @param n.earlystop the early stopping parameter. If the number of patients treated at the current
#'                    dose reaches \code{n.earlystop}, stop the trial or subtrial and select the MTD based on
#'                    the observed data. When the waterfall design is used to find the MTD contour,
#'                    \code{n.earlystop=12} by default.
#' @param startdose the starting dose combination level for drug combination trial
#' @param titration set \code{titration=TRUE} to perform dose escalation with cohort size = 1 to accelerate dose escalation at the begining of the trial.
#' @param p.saf the highest toxicity probability that is deemed subtherapeutic (i.e. below the MTD)
#'              such that dose escalation should be undertaken.
#'              The default value is \code{p.saf=0.6*target}.
#' @param p.tox the lowest toxicity probability that is deemed overly toxic such that deescalation
#'              is required. The default value is \code{p.tox=1.4*target}.
#' @param cutoff.eli the cutoff to eliminate an overly toxic dose for safety. We recommend the
#'                   default value of (\code{cutoff.eli=0.95}) for general use.
#' @param extrasafe set \code{extrasafe=TRUE} to impose a more stringent stopping rule
#' @param offset a small positive number (between 0 and 0.5) to control how strict the stopping
#'               rule is when \code{extrasafe=TRUE}. A larger value leads to a more strict stopping
#'               rule. The default value \code{offset=0.05} generally works well.
#' @param ntrial the total number of trials to be simulated
#' @param mtd.contour set \code{mtd.contour=TRUE} to select the MTD contour (claiming multiple MTDs).
#'                    Otherwise, BOIN design is used to search for a single MTD.
#' @param boundMTD set \code{boundMTD=TRUE} to impose the condition: the isotonic estimate of toxicity
#'                 probability for the selected MTD must be less than de-escalation boundary.
#' @param explore_deescalation TRUE or FALSE. Whether to go to unexplored dose in de-escalation, disregarding the posterior probability.
#' @param seed the random seed for simulation
#'
#' @details The operating characteristics of the BOIN-CombP design are generated by
#' simulating trials under the prespecified true toxicity probabilities of the investigational dose
#' combinations. If \code{titration=TRUE}, we perform dose escalation with cohort size = 1 at the begining of the trial:
#' starting from \code{startdose}, if no toxicity is observed, we escalate the dose;
#' otherwise, the titration is completed and we switch to cohort size = \code{cohortsize}.
#' Titration accelerates the dose escalation and is useful when low doses are believed to be safe.
#'
#' When selecting the next dose in escalation/de-escalation, the dose with higher posterior
#' probability of being in the optimal interval is selected as the next dose.
#' When the posterior probability of the two candidate doses being in the
#' optimal interval is equal or both candidate doses have no data, the next
#' dose is selected according to the preference matrix. When one candidate dose
#' has data, the other has not, the next dose is the candidate dose with no data.
#'
#'
#' The BOIN-CombP design has two built-in stopping rules:
#' (1) stop the trial/subtrial if the lowest dose is eliminated due to toxicity, and no dose should
#' be selected as the MTD; and (2) stop the trial/subtrial and select the MTD if the number of
#' patients treated at the current dose reaches \code{n.earlystop}. The first stopping rule is a safety
#' rule to protect patients from the case in which all doses are overly toxic. The rationale for
#' the second stopping rule is that when there is a large number (i.e., \code{n.earlystop}) of
#' patients assigned to a dose, it means that the dose-finding algorithm has approximately converged.
#' Thus, we can stop the trial/subtrial early and select the MTD to save sample size and reduce the
#' trial duration.
#'
#'
#'  For some applications, investigators may prefer a more strict safety stopping rule than rule
#'  (1) for extra safety when the lowest dose is overly toxic.
#'  This can be achieved by setting \code{extrasafe=TRUE},
#'  which imposes the following more strict safety stopping rule:
#'  stop the trial if (i) the number of patients treated at the lowest dose \code{>=3},
#' and (ii) \eqn{Pr(toxicity\ rate\ of\ the\ lowest\ dose > \code{target} | data) > \code{cutoff.eli}-\code{offset}}.
#' As a tradeoff, the strong stopping rule will decrease the MTD selection percentage
#'  when the lowest dose actually is the MTD.
#'
#' @return \code{get.oc.combP()} returns the operating characteristics of the BOIN combination or
#' waterfall design as a list. For the BOIN combination design, including:
#' (1) true toxicity probability at each dose level (\code{$p.true}),
#' (2) preference at each dose level (\code{$preferred.doses}),
#' (3) selection percentage at each dose level (\code{$selpercent}),
#' (4) the number of patients treated at each dose level (\code{$npatients})
#' (5) the number of toxicities observed at each dose level (\code{$ntox}),
#' (6) the total number of patients in the trial (\code{$totaln}),
#' (7) the total number of toxicities observed for the trial (\code{$totaltox})
#' (8) the percentage of correct selection (\code{$pcs}),
#' (9) the percentage of acceptable selection (\code{$pas}),
#' (10) the total percentage of patients treated at the MTD (\code{$npercent}).
#' (11) the percentage of early stopping without selecting the MTD (\code{$percentstop})
#'
#'
#' @note We should avoid setting the values of \code{p.saf} and \code{p.tox} very close to the
#'      \code{target}. This is because the small sample sizes of typical phase I trials prevent us from
#'       differentiating the target DLT rate from the rates close to it. The default values provided by
#'       \code{get.oc()} are strongly recommended, and generally yield excellent operating characteristics.
#'
#'
#' @author Yuxuan Chen, Haiming Zhou, and Philip He.
#'
#' @references Liu S. and Yuan, Y. (2015). Bayesian Optimal Interval Designs for Phase I Clinical
#'             Trials, \emph{Journal of the Royal Statistical Society: Series C}, 64, 507-523.
#'
#'            Lin R. and Yin, G. (2017). Bayesian Optimal Interval Designs for Dose Finding in
#'            Drug-combination Trials, \emph{Statistical Methods in Medical Research}, 26, 2155-2167.
#'
#'            Yan, F., Zhang, L., Zhou, Y., Pan, H., Liu, S. and Yuan, Y. (2020).BOIN: An R Package
#'            for Designing Single-Agent and Drug-Combination Dose-Finding Trials Using Bayesian Optimal
#'            Interval Designs. \emph{Journal of Statistical Software}, 94(13),1-32.<doi:10.18637/jss.v094.i13>.
#'
#'
#'            Zhang L. and Yuan, Y. (2016). A Simple Bayesian Design to Identify the Maximum
#'            Tolerated Dose Contour for Drug Combination Trials, \emph{Statistics in Medicine}, 35, 4924-4936.
#'
#' @examples
#'
#' ###### drug-combination trial ######
#'
#' ##### combination trial to find a single MTD  ######
#'
#' ## get the operating characteristics for BOIN design
#' S1.p.true <- matrix(c(0.02, 0.07, 0.10,
#' 0.07, 0.10, 0.15,
#' 0.10, 0.15, 0.30,
#' 0.15, 0.30, 0.45,
#' 0.30, 0.45, 0.55), nrow = 3, byrow = FALSE)

#' doses.cp <- matrix(c(1, -1, -1, -1, -1,
#'       1, 1,  1, 1, -1,
#'       1, 1, 1, 1, 1),
#'       ncol = 5, byrow = TRUE)
#' oc.comb <- get.oc.combP(target=0.3, p.true=S1.p.true, ncohort=10, cohortsize=3,
#'                                preferred.doses = doses.cp, n.earlystop=9, startdose=c(1,1), ntrial=1000)
#'
#' summary(oc.comb)
#' plot(oc.comb)
#'
#'
#'
#' @import BOIN
#' @import stats
#' @export


get.oc.combP <- function (target, p.true, ncohort, cohortsize, preferred.doses, n.earlystop = NULL,
                             startdose = c(1, 1), titration = FALSE, p.saf = 0.6 * target,
                             p.tox = 1.4 * target, cutoff.eli = 0.95, extrasafe = FALSE, explore_deescalation = FALSE,
                             offset = 0.05, ntrial = 1000, mtd.contour = FALSE, boundMTD=FALSE,seed = 6)
{
  get.oc.comb.boin <- function(target, p.true, ncohort, cohortsize, preferred.doses,
                               n.earlystop = 100, startdose = c(1, 1), titration = FALSE, explore_deescalation = FALSE,
                               p.saf = 0.6 * target, p.tox = 1.4 * target, cutoff.eli = 0.95,
                               extrasafe = FALSE, offset = 0.05, boundMTD=FALSE,ntrial = 1000) {
    JJ = nrow(p.true)
    KK = ncol(p.true)
    if (JJ > KK)
      stop("p.true should be arranged in a way (i.e., rotated) such that\n          the number of rows is less than or equal to the number of columns.")
    if (JJ > KK)
      p.true = t(p.true)
    if (target < 0.05) {
      stop("the target is too low!")
    }
    if (target > 0.6) {
      stop("the target is too high!")

    }
    if ((target - p.saf) < (0.1 * target)) {
      stop("the probability deemed safe cannot be higher than or too close to the target!")
    }
    if ((p.tox - target) < (0.1 * target)) {
      stop("the probability deemed toxic cannot be lower than or too close to the target!")
    }
    if (offset >= 0.5) {
      stop("the offset is too large!")
    }
    if (n.earlystop <= 6) {
      warning("the value of n.earlystop is too low to ensure good operating characteristics. Recommend n.earlystop = 9 to 18")
    }
    if (preferred.doses[startdose[1], startdose[2]]!=1){
      stop("Start dose must be preferred dose!")
    }
    ndose = length(p.true)
    npts = ncohort * cohortsize
    Y <- array(matrix(rep(0, length(p.true) * ntrial), dim(p.true)[1]),
               dim = c(dim(p.true), ntrial))
    N <- array(matrix(rep(0, length(p.true) * ntrial), dim(p.true)[1]),
               dim = c(dim(p.true), ntrial))
    dselect = matrix(rep(0, 2 * ntrial), ncol = 2) # selected dose default set to 0

    ## get boundary parameters -------------------------------------------------
    if (cohortsize > 1) {
      temp = get.boundary(target, ncohort, cohortsize,
                          n.earlystop=ncohort*cohortsize, p.saf, p.tox, cutoff.eli, extrasafe)$full_boundary_tab
    }else {
      temp = get.boundary(target, ncohort, cohortsize,
                          n.earlystop=ncohort*cohortsize, p.saf, p.tox, cutoff.eli, extrasafe)$boundary_tab
    }
    b.e = temp[2, ]
    b.d = temp[3, ]
    b.elim = temp[4, ]
    lambda1 = log((1 - p.saf)/(1 - target))/log(target *
                                                  (1 - p.saf)/(p.saf * (1 - target)))
    lambda2 = log((1 - target)/(1 - p.tox))/log(p.tox * (1 -
                                                           target)/(target * (1 - p.tox)))


    if (cohortsize == 1)
      titration = FALSE

    # simulation trials -------------------------------------------------------
    for (trial in 1:ntrial) {

      if(trial==200){
        xx=1
      }
      y <- matrix(rep(0, ndose), dim(p.true)[1], dim(p.true)[2]) # DLT patients
      n <- matrix(rep(0, ndose), dim(p.true)[1], dim(p.true)[2]) # patients treated
      earlystop = 0 # flag for elimination stop
      d = startdose
      elimi = matrix(rep(0, ndose), dim(p.true)[1], dim(p.true)[2])
      elimi = elimi + (preferred.doses==-1) # not considered doses are flagged as eliminate
      ft=TRUE #flag used to determine whether or not to add cohortsize-1 patients to a dose for the first time when titration is triggered.
      if (titration) {
        tmpa = d[1]
        tmpb = d[2]
        y[tmpa, tmpb] <- (runif(1) < p.true[tmpa, tmpb])
        n[tmpa, tmpb] <- 1
        while (tmpa <= dim(p.true)[1] & tmpb <= dim(p.true)[2]) {
          if (tmpa == dim(p.true)[1] & tmpb == dim(p.true)[2]) {
            break
          }
          if (sum(y) == 1) {
            y[tmpa, tmpb] = 1
            break
          }
          if (tmpa < dim(p.true)[1] & tmpb < dim(p.true)[2]) {
            tmp.candidate = rbind(c(tmpa + 1, tmpb),
                                  c(tmpa, tmpb + 1))
            tmp.sel = rbinom(1, 1, prob = c(0.5, 0.5)) +
              1
            tmpa = tmp.candidate[tmp.sel, 1]
            tmpb = tmp.candidate[tmp.sel, 2]
          }
          else if (tmpa == dim(p.true)[1]) {
            tmpb = tmpb + 1
          }
          else {
            tmpa = tmpa + 1
          }
          y[tmpa, tmpb] <- (runif(1) < p.true[tmpa, tmpb])
          n[tmpa, tmpb] <- 1
        }
        if (sum(y) == 0) {
          d = c(dim(p.true)[1], dim(p.true)[2])
        }
        else {
          d = c(tmpa, tmpb)
        }
      }
      for (pp in 1:ncohort) {

        ## generate DLT for enrolled patient in this cohort -----------------------
        if (titration & n[d[1], d[2]] < cohortsize & ft) {
          ft=FALSE

          y[d[1], d[2]] = y[d[1], d[2]] + sum(runif(cohortsize -
                                                      1) < p.true[d[1], d[2]])
          n[d[1], d[2]] = n[d[1], d[2]] + cohortsize -1
        }
        else {
          y[d[1], d[2]] = y[d[1], d[2]] + sum(runif(cohortsize) <
                                                p.true[d[1], d[2]])
          n[d[1], d[2]] = n[d[1], d[2]] + cohortsize
        }



        nc = n[d[1], d[2]] #the updated number of patients treated for this dose

        ## examine elimination -------------------------------------------------
        if (!is.na(b.elim[nc])) { # if eliminated boundary exists

          if (y[d[1], d[2]] >= b.elim[nc]) { # if number of DLTs in current dose exceeds elimination boundary


            for (i in min(d[1], dim(p.true)[1]):dim(p.true)[1]) { # set elimination status for current and higher dose to 1
              for (j in min(d[2], dim(p.true)[2]):dim(p.true)[2]) {
                elimi[i, j] = 1
              }
            }

            if (d[1] == 1 && d[2] == 1) { # if current dose is lowest dose, early stop
              d = c(99, 99)
              earlystop = 1
              break
            }
          }


          if (extrasafe) {
            if (d[1] == 1 && d[2] == 1 && n[1, 1] >=
                3) {
              if (1 - pbeta(target, y[1, 1] + 1, n[1,
                                                   1] - y[1, 1] + 1) > cutoff.eli - offset) {
                d = c(99, 99)
                earlystop = 1
                break
              }
            }
          }
        }

        ## check if need to stop the trial ----------------------------------------
        if (n[d[1],d[2]] >= n.earlystop  &&  # MUST: current dose reach early stop cohort size and satisfy one of the following:
            (y[d[1],d[2]]>b.e[n[d[1],d[2]]] || #  current dose reach elimination boundary
             (d[1]==dim(p.true)[1] && d[2]==dim(p.true)[2]) || #  current dose is highest dose
             ( d[1]==dim(p.true)[1] && d[2]<dim(p.true)[2] && elimi[d[1],d[2]+1]==1 ) || # higher dose eliminated in one direction, current dose reach highest dose in one drug
             ( d[1]<dim(p.true)[1] && d[2]==dim(p.true)[2] && elimi[d[1]+1,d[2]]==1 ) ||
             ( d[1]<dim(p.true)[1] && d[2]<dim(p.true)[2] && elimi[d[1]+1,d[2]]==1 && elimi[d[1],d[2]+1]==1 ) )  && # higher dose eliminated in both directions
            (y[d[1],d[2]]<b.d[n[d[1],d[2]]] || (d[1]==1 && d[2]==1) ) ) break; # MUST: DLTs below de-escalation boundary or current dose is the lowest dose


        ## escalate ---------------------------------
        if (y[d[1], d[2]] <= b.e[nc]) {
          if(d[1]==dim(p.true)[1] && d[2] < dim(p.true)[2] ){ # if reach boundary in one direction
            d = d + c(0,1)*( preferred.doses[d[1],d[2]+1]>=0)
          }else if (d[1]<dim(p.true)[1] && d[2] == dim(p.true)[2]){ # if reach boundary in one direction
            d = d + c(1,0)*( preferred.doses[d[1]+1,d[2]]>=0)
          }else{
            elevel = matrix(c(1, 0, 0, 1), 2) # Two potential escalation directions
            pr_H0 = rep(0, length(elevel)/2) # to store probabilities for two potential dose
            nn = yn = pr_H0 # store number of patients treated at each candidate dose and number of DLT
            prefer = rep(0, length(elevel)/2) # to store preference for two candidate dose
            for (i in seq(1, length(elevel)/2, by = 1)) { # check for two candidates
              if (d[1] + elevel[1, i] <= dim(p.true)[1] && # check if candidate dose is within the dose matrix
                  d[2] + elevel[2, i] <= dim(p.true)[2]) {
                prefer[i] = preferred.doses[d[1] + elevel[1, i], d[2] + elevel[2, i]]
                if (elimi[d[1] + elevel[1, i], d[2] + elevel[2,
                                                             i]] == 0) { # if candidate has not been eliminated
                  yn[i] = y[d[1] + elevel[1, i], d[2] + elevel[2,
                                                            i]] # observed DLTs at candidate dose
                  nn[i] = n[d[1] + elevel[1, i], d[2] +
                              elevel[2, i]] # observed number of patients at candidate dose
                  pr_H0[i] <- pbeta(lambda2, yn[i] + 0.5, nn[i] - yn[i] + 0.5) -
                    pbeta(lambda1, yn[i] + 0.5, nn[i] - yn[i] + 0.5) # prob of within target DLT boundary


                }
              }
            }

            pr_H0 = pr_H0 + nn * 5e-04 + ifelse(prefer==-1, -99,0) # negative prob for not considered dose # avoid zero prob if candidate dose have patients
            # if (max(pr_H0) <= 0) { ##!!! no valid escalation if both not considered or both outside of dose matrix
            #   d = d
            # }else { ## select candidate dose based on preference and posterior prob
            #   if(min(prefer)<0){ # if one dose not considered, go to the other dose
            #     k = which.max(prefer)
            #   }else if(prefer[1] != prefer[2]){ # one prefered, one low priority
            #     if(max(nn)==0 || min(pr_H0)==max(pr_H0)){ k = which.max(prefer)} # if both have no data or have equal prob, go to the preferred dose
            #     else if(min(nn)>0){ k = which.max(pr_H0)} # if both have data and not equal prob, go to higher prob
            #     else if(max(nn)>0 & min(nn)==0){ # if one has data, the other has not
            #       if(yn[which.max(nn)] <= b.e[nn]){k = 1+round(runif(1))} # not toxic, random
            #       else if(yn[which.max(nn)] >= b.d[nn]){k = which.min(nn)} # toxic go to the other dose
            #       }
            #   }else if(prefer[1] == prefer[2]){ # same priority
            #     if(max(nn)==0 || min(pr_H0)==max(pr_H0)){ k = 1+round(runif(1))} # if both have no data or have equal prob, random pick with equal allocation
            #     else if(min(nn)>0){ k = which.max(pr_H0)} # if both have data and not equal prob, go to higher prob
            #     else if(max(nn)>0 & min(nn)==0){ k = which.min(nn)} # if one has data, the other has not, go to the one has no data
            #
            #   }
            #   d = d + c(elevel[1, k], elevel[2, k])
            # }
            if (max(prefer) <= 0) { ##!!! no valid escalation if both not considered or both outside of dose matrix
              d = d
            }else { ## select candidate dose based on preference and posterior prob
              if(min(prefer)<0){ # if one dose not considered, go to the other dose
                k = which.max(prefer)
                d = d + c(elevel[1, k], elevel[2, k])
              }else if(prefer[1] == prefer[2] && min(nn)>0 && max(pr_H0)>min(pr_H0)){ # if both considered and both have data, go the the dose with higher posterior prob
                k = which.max(pr_H0)
                d = d + c(elevel[1, k], elevel[2, k])
              }else{
                k = 1+round(runif(1))
                d = d + c(elevel[1, k], elevel[2, k])
              }
            }
          }
        }
        ## de-escalate ----------------------------
        else if (y[d[1], d[2]] >= b.d[nc]) {
          if(d[1]==1 && d[2] > 1 ){ # if reach boundary in one direction
            d = d + c(0,-1)*( preferred.doses[d[1],d[2]-1]>=0)
          }else if (d[1]>1 && d[2] == 1){ # if reach boundary in one direction
            d = d + c(-1,0)*( preferred.doses[d[1]-1,d[2]]>=0)
          }else{
            delevel = matrix(c(-1, 0, 0, -1), 2)
            pr_H0 = rep(0, length(delevel)/2)
            nn = yn = pr_H0
            prefer = rep(0, length(elevel)/2) # to store preference for two candidate dose
            for (i in seq(1, length(delevel)/2, by = 1)) {
              if (d[1] + delevel[1, i] > 0 && d[2] + delevel[2,
                                                             i] > 0) {
                yn[i] = y[d[1] + delevel[1, i], d[2] + delevel[2,
                                                            i]]
                nn[i] = n[d[1] + delevel[1, i], d[2] +
                            delevel[2, i]]
                pr_H0[i] = pbeta(lambda2, yn[i] + 0.5, nn[i] - yn[i] + 0.5) -
                  pbeta(lambda1, yn[i] + 0.5, nn[i] - yn[i] + 0.5)

                prefer[i] = preferred.doses[d[1] + delevel[1, i], d[2] + delevel[2, i]]
              }
            }
            pr_H0 = (pr_H0 + nn * 5e-04) + ifelse(prefer==-1, -99,0) # negative prob for not considered dose

            # if (max(pr_H0) <= 0) { # for dose with no de-escalation option
            #   d = d
            # }
            # else {
            #   ## select candidate dose based on preference and posterior prob
            #   if(min(prefer)<0){ # if one dose not considered, go to the other dose
            #     k = which.max(prefer)
            #   }else if(prefer[1] != prefer[2]){ # one prefered, one low priority
            #     if(max(nn)==0 || min(pr_H0)==max(pr_H0)){ k = which.max(prefer)} # if both have no data or have equal prob, go to the preferred dose
            #     else if(min(nn)>0){ k = which.max(pr_H0)} # if both have data and not equal prob, go to higher prob
            #     else if(max(nn)>0 & min(nn)==0){
            #       if(yn[which.max(nn)] <= b.e[nn]){k = 1+round(runif(1))} # not toxic, random
            #       else if(yn[which.max(nn)] >= b.d[nn]){k = which.min(nn)} # toxic go to the other dose
            #       } # if one has data, the other has not, go to the one has no data
            #   }else if(prefer[1] == prefer[2]){ # same priority
            #     if(max(nn)==0 || min(pr_H0)==max(pr_H0)){ k = 1+round(runif(1))} # if both have no data or have equal prob, random pick with equal allocation
            #     else if(min(nn)>0){ k = which.max(pr_H0)} # if both have data and not equal prob, go to higher prob
            #     else if(max(nn)>0 & min(nn)==0){ k = which.min(nn)} # if one has data, the other has not, go to the one has no data
            #   }
            #
            #   d = d + c(delevel[1, k], delevel[2, k])
            #
            # }
            if (max(prefer) <= 0) { # for dose with no de-escalation option
              d = d
            }else if(min(prefer)<0){ # if one dose not considered, go to the other dose
              k = which.max(prefer)
              d = d + c(delevel[1, k], delevel[2, k])
            }else if(prefer[1] == prefer[2] && min(nn)>0 && max(pr_H0)>min(pr_H0)){ # if both considered and both have data, go the the dose with higher posterior prob
              k = which.max(pr_H0)
              d = d + c(delevel[1, k], delevel[2, k])
            }else if(explore_deescalation && sum(nn==0)>0){ # explore the untested dose in de-escalation
              k = which(nn==0)[1]
              d = d + c(delevel[1, k], delevel[2, k])
            }else{
              k = 1+round(runif(1))
              d = d + c(delevel[1, k], delevel[2, k])
            }
          }
        }
        else { ## stay ----------------------------------------------------------
          d = d
        }


      }
      Y[, , trial] = y
      N[, , trial] = n
      if (earlystop == 1) {
        dselect[trial, ] = c(99, 99)
      }else {
        selcomb = select.mtd.comb.boin(target, n, y,
                                       cutoff.eli, extrasafe, offset,
                                       boundMTD=boundMTD,p.tox=p.tox,mtd.contour = FALSE)$MTD
        dselect[trial, 1] = selcomb[1]
        dselect[trial, 2] = selcomb[2]
      }

      # print(n[c(1,4,5,8,9,12)])
      # print(y[c(1,4,5,8,9,12)])
    }
    selpercent = matrix(rep(0, ndose), dim(p.true)[1], dim(p.true)[2])
    nptsdose = apply(N, c(1, 2), mean, digits = 2, format = "f")
    ntoxdose = apply(Y, c(1, 2), mean, digits = 2, format = "f")
    for (i in 1:dim(p.true)[1]) for (j in 1:dim(p.true)[2]) {
      {
        selpercent[i, j] = sum(dselect[, 1] == i & dselect[,
                                                           2] == j)/ntrial * 100
      }
    }
    names_vector <- c("NO", "LowP", "Prefer")
    preferred.doses.c = matrix(names_vector[preferred.doses+2],
                               nrow = nrow(preferred.doses),
                               ncol = ncol(preferred.doses))


    if (JJ <= KK) {
      rownames(p.true) = paste("DoseA", 1:dim(p.true)[1],
                               sep = "")
      colnames(p.true) = paste("DoseB", 1:dim(p.true)[2],
                               sep = "")
      rownames(selpercent) = paste("DoseA", 1:dim(p.true)[1],
                                   sep = "")
      colnames(selpercent) = paste("DoseB", 1:dim(p.true)[2],
                                   sep = "")
      rownames(preferred.doses.c) = paste("DoseA", 1:dim(p.true)[1],
                               sep = "")
      colnames(preferred.doses.c) = paste("DoseB", 1:dim(p.true)[2],
                               sep = "")
      out = list(p.true = round(p.true, 2), preferred.doses = preferred.doses.c, selpercent = round(selpercent,2),
                 npatients = round(apply(N, c(1, 2), mean),2), ntox = round(apply(Y, c(1, 2), mean), 2),
                 totaltox = round(sum(Y)/ntrial, 1), totaln = round(sum(N)/ntrial,1),
                 pcs = paste(round(sum(selpercent[which(abs(p.true -target) == min(abs(p.true - target)), arr.ind = TRUE)]),1), "%", sep = ""),
                 pas = paste(round(sum(selpercent[which((p.true<=0.33 & p.true>=0.16), arr.ind = TRUE)]),1), "%"),
                 npercent = paste(round(sum(nptsdose[which(abs(p.true -target) == min(abs(p.true - target)), arr.ind = TRUE)])/sum(nptsdose) *100, 1), "%", sep = ""),
                 percentstop=100-sum(round(selpercent,2)),flowchart = FALSE)
      rownames(out$npatients) = paste("DoseA", 1:dim(p.true)[1],
                                      sep = "")
      colnames(out$npatients) = paste("DoseB", 1:dim(p.true)[2],
                                      sep = "")
      rownames(out$ntox) = paste("DoseA", 1:dim(p.true)[1],
                                 sep = "")
      colnames(out$ntox) = paste("DoseB", 1:dim(p.true)[2],
                                 sep = "")

      return(out)
    }
    else {
      colnames(p.true) = paste("DoseB", 1:dim(t(p.true))[1],
                               sep = "")
      rownames(p.true) = paste("DoseA", 1:dim(t(p.true))[2],
                               sep = "")
      colnames(preferred.doses.c) = paste("DoseB", 1:dim(t(p.true))[1],
                                          sep = "")
      rownames(preferred.doses.c) = paste("DoseA", 1:dim(t(p.true))[2],
                                          sep = "")
      colnames(selpercent) = paste("DoseB", 1:dim(t(p.true))[1],
                                   sep = "")
      rownames(selpercent) = paste("DoseA", 1:dim(t(p.true))[2],
                                   sep = "")
      colnames(npatients) = paste("DoseB", 1:dim(t(p.true))[1],
                                  sep = "")
      rownames(npatients) = paste("DoseA", 1:dim(t(p.true))[2],
                                  sep = "")
      colnames(ntox) = paste("DoseB", 1:dim(t(p.true))[1],
                             sep = "")
      rownames(ntox) = paste("DoseA", 1:dim(t(p.true))[2],
                             sep = "")
      out = list(p.true = round(t(p.true), 2), preferred.doses = preferred.doses.c,  selpercent = round(t(selpercent),2),
                 npatients = round(t(apply(N, c(1, 2), mean)), 2), ntox = round(t(apply(Y, c(1, 2), mean)),2),
                 totaltox = round(sum(Y)/ntrial, 1), totaln = round(sum(N)/ntrial,1),
                 pcs = paste(round(sum(selpercent[which(abs(p.true -target) == min(abs(p.true - target)), arr.ind = TRUE)]),
                                                                                                        1), "%"),
                 pas = paste(round(sum(selpercent[which((p.true<=0.33 & p.true>=0.16), arr.ind = TRUE)]),1), "%"),
                 npercent = paste(round(sum(nptsdose[which(abs(p.true -target) == min(abs(p.true - target)), arr.ind = TRUE)])/sum(nptsdose) *100, 1), "%"),
                 percentstop=100-sum(round(selpercent,2)),
                 flowchart = FALSE)

      return(out)
    }
  }
  select.mtd.comb.boin <- function(target, npts, ntox, cutoff.eli = 0.95,
                                   extrasafe = FALSE, offset = 0.05,
                                   boundMTD=FALSE,p.tox=1.4*target,
                                   mtd.contour = FALSE) {
    lambda_d = log((1 - target)/(1 - p.tox))/log(p.tox * (1 -target)/(target * (1 - p.tox)))
    y = ntox
    n = npts
    if (nrow(n) > ncol(n) | nrow(y) > ncol(y)) {
      stop("npts and ntox should be arranged in a way (i.e., rotated) such that for each of them, the number of rows is less than or equal to the number of columns.")
    }
    elimi = matrix(0, dim(n)[1], dim(n)[2])
    if (extrasafe) {
      if (n[1, 1] >= 3) {
        if (1 - pbeta(target, y[1, 1] + 1, n[1, 1] -
                      y[1, 1] + 1) > cutoff.eli - offset) {
          elimi[, ] = 1
        }
      }
    }
    for (i in 1:dim(n)[1]) {
      for (j in 1:dim(n)[2]) {
        if (n[i, j] >= 3) {
          if (1 - pbeta(target, y[i, j] + 1, n[i, j] -
                        y[i, j] + 1) > cutoff.eli) {
            elimi[i:dim(n)[1], j] = 1
            elimi[i, j:dim(n)[2]] = 1
            break
          }
        }
      }
    }

    selectdose=NULL
    if (elimi[1] == 1) {

      selectdose = c(99, 99)
      selectdoses = matrix(selectdose, nrow = 1)

    }else {

      phat = (y + 0.05)/(n + 0.1)
      phat = Iso::biviso(phat, n + 0.1, warn = TRUE)[,
      ]
      phat.out = phat
      phat.out[n == 0] = NA
      phat[elimi == 1] = 1.1
      phat = phat * (n != 0) + (1e-05) * (matrix(rep(1:dim(n)[1],
                                                     each = dim(n)[2], len = length(n)), dim(n)[1],
                                                 byrow = T) + matrix(rep(1:dim(n)[2], each = dim(n)[1],
                                                                         len = length(n)), dim(n)[1]))


      if(boundMTD){

        if(all(phat[n!=0]>=lambda_d)){
          selectdose = c(99, 99)


          selectdoses = matrix(selectdose, nrow = 1)
        }else{
          phat[phat>=lambda_d]=10}}

      if(is.null(selectdose)){

        phat[n == 0] = 10
        selectdose = which(abs(phat - target) == min(abs(phat -
                                                           target)), arr.ind = TRUE)
        if (length(selectdose) > 2)
          selectdose = selectdose[1, ]
        aa = function(x) as.numeric(as.character(x))
        if (mtd.contour == TRUE) {
          selectdoses = cbind(row = 1:dim(n)[1], col = rep(99,
                                                           dim(n)[1]))
          for (k in dim(n)[1]:1) {
            kn = n[k, ]
            ky = y[k, ]
            kelimi = elimi[k, ]
            kphat = phat[k, ]
            if (kelimi[1] == 1 || sum(n[kelimi == 0]) ==
                0) {
              kseldose = 99
            }
            else {
              adm.set = (kn != 0) & (kelimi == 0)
              adm.index = which(adm.set == T)
              y.adm = ky[adm.set]
              n.adm = kn[adm.set]
              selectd = sort(abs(kphat[adm.set] - target),
                             index.return = T)$ix[1]
              kseldose = adm.index[selectd]
            }
            selectdoses[k, 2] = ifelse(is.na(kseldose),
                                       99, kseldose)
            if (k < dim(n)[1])
              if (selectdoses[k + 1, 2] == dim(n)[2])
                selectdoses[k, 2] = dim(n)[2]
            if (k < dim(n)[1])
              if (aa(selectdoses[k + 1, 2]) == dim(n)[2] &
                  aa(selectdoses[k + 1, 2]) == aa(selectdoses[k,
                                                              2]))
                selectdoses[k, 2] = 99
          }
        }
        else {
          selectdoses = matrix(99, nrow = 1, ncol = 2)
          selectdoses[1, ] = matrix(selectdose, nrow = 1)
        }
        selectdoses = matrix(selectdoses[selectdoses[, 2] !=
                                           99, ], ncol = 2)
      }

      colnames(selectdoses) = c("DoseA", "DoseB")
    }
    if (mtd.contour == FALSE) {
      if (selectdoses[1, 1] == 99 && selectdoses[1, 2] ==
          99) {

        out=list(target = target, MTD = 99, p_est = matrix(NA,
                                                           nrow = dim(npts)[1], ncol = dim(npts)[2]))

        return(out)
      }
      else {
        out=list(target = target, MTD = selectdoses,
                 p_est = round(phat.out, 2))

        return(out)
      }
    }
    else {
      if (length(selectdoses) == 0) {
        out=list(target = target, MTD = 99, p_est = matrix(NA,
                                                           nrow = dim(npts)[1], ncol = dim(npts)[2]))


        return(out)

      }
      else {
        out=list(target = target, MTD = selectdoses,
                 p_est = round(phat.out, 2))

        return(out)
      }
    }
  }

  set.seed(seed)
  JJ = nrow(p.true)
  KK = ncol(p.true)
  if (JJ > KK) {
    stop("p.true should be arranged in a way (i.e., rotated) such that the number of rows is less than or equal to the number of columns.")

  }
  if (mtd.contour == FALSE) {
    if (is.null(n.earlystop) == TRUE)
      n.earlystop = 100
    if (n.earlystop <= 6) {
      warning("the value of n.earlystop is too low to ensure good operating characteristics. Recommend n.earlystop = 9 to 18 ")
    }
    if (length(ncohort) > 1) {
      warning("ncohort is the total number of cohorts for the trial. Please enter a scalar.")
    }
    if (((JJ * KK) <= 4) & (sum(ncohort) <= 6)) {
      warning("the sample size is too small, which may lead to poor operating characteristics. Suggest to increase the number of cohort.")
    }
    if (((JJ * KK) > 4) & (sum(ncohort) <= 8)) {
      warning("the sample size is too small, which may lead to poor operating characteristics. Suggest to increase the number of cohort.")
    }
    out=get.oc.comb.boin(target = target, p.true = p.true,
                         ncohort = sum(ncohort), cohortsize = cohortsize,
                         preferred.doses = preferred.doses,
                         n.earlystop = n.earlystop, startdose = startdose,
                         titration = titration,
                         p.saf = p.saf, p.tox = p.tox,
                         cutoff.eli = cutoff.eli, extrasafe = extrasafe,
                         offset = offset,boundMTD=boundMTD,
                         explore_deescalation = explore_deescalation,
                         ntrial = ntrial)
    class(out)<-"boin"
    return(out)
  }

}
