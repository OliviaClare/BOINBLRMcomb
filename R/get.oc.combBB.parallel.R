#'
#' Generate operating characteristics for drug combination trials
#'
#' Obtain the operating characteristics of the BOIN-CombP design for drug combination
#'  trials. The BOIN-CombP design is to find a MTD within specified drug combinations in the dose matrix.
#'
#' @usage get.oc.combBB.parallel(BLRMspecs, target, p.true, ncohort, cohortsize, preferred.doses, n.earlystop=NULL, startdose=c(1, 1),
#'                    titration=FALSE,p.saf=0.6*target, p.tox=1.4*target, cutoff.eli=0.95,
#'                    extrasafe=FALSE,offset=0.05, ntrial=1000, mtd.contour=FALSE,
#'                    boundMTD=FALSE, seed=6)
#'
#' @param BLRMspecs The priors and parameters needed for BLRM (see package blrm for detailed specification)
#' @param target the target DLT rate
#' @param p.true a \code{J*K} matrix \code{(J<=K)} containing the true toxicity probabilities of
#'               combinations with \code{J} dose levels of agent A and \code{K} dose levels of agent B
#' @param ncohort a \code{1*J} vector specifying the number of cohorts for each of \code{J} subtrials
#'                if \code{mtd.contour=TRUE}; Otherwise, a scalar specifying the total number of cohorts for
#'                the trial.
#' @param cohortsize the cohort size
#' @param preferred.doses the matrix that specifies the preference of each dose combination: 1 for preferred; 0 for less preferred; -1 for excluded.
#' @param n.earlystop the early stopping parameter. If the number of patients treated at the current
#'                    dose reaches \code{n.earlystop}, stop the trial or subtrial and select the MTD based on
#'                    the observed data. When the waterfall design is used to find the MTD contour,
#'                    \code{n.earlystop=12} by default.
#' @param startdose the starting dose combination level for drug combination trial
#' @param titration set \code{titration=TRUE} to perform dose escalation with cohort size = 1 to accelerate dose escalation at the begining of the trial.
#' @param p.saf the highest toxicity probability that is deemed subtherapeutic (i.e. below the MTD)
#'              such that dose escalation should be undertaken.
#'              The default value is \code{p.saf=0.6*target}.
#' @param p.tox the lowest toxicity probability that is deemed overly toxic such that deescalation
#'              is required. The default value is \code{p.tox=1.4*target}.
#' @param cutoff.eli the cutoff to eliminate an overly toxic dose for safety. We recommend the
#'                   default value of (\code{cutoff.eli=0.95}) for general use.
#' @param extrasafe set \code{extrasafe=TRUE} to impose a more stringent stopping rule
#' @param offset a small positive number (between 0 and 0.5) to control how strict the stopping
#'               rule is when \code{extrasafe=TRUE}. A larger value leads to a more strict stopping
#'               rule. The default value \code{offset=0.05} generally works well.
#' @param ntrial the total number of trials to be simulated
#' @param mtd.contour set \code{mtd.contour=TRUE} to select the MTD contour (claiming multiple MTDs).
#'                    Otherwise, BOIN design is used to search for a single MTD.
#' @param boundMTD set \code{boundMTD=TRUE} to impose the condition: the isotonic estimate of toxicity
#'                 probability for the selected MTD must be less than de-escalation boundary.
#' @param explore_deescalation TRUE or FALSE. Whether to go to unexplored dose in de-escalation, disregarding the posterior probability.
#' @param seed the random seed for simulation
#'
#' @details The operating characteristics of the BOIN-CombP design are generated by
#' simulating trials under the prespecified true toxicity probabilities of the investigational dose
#' combinations. If \code{titration=TRUE}, we perform dose escalation with cohort size = 1 at the begining of the trial:
#' starting from \code{startdose}, if no toxicity is observed, we escalate the dose;
#' otherwise, the titration is completed and we switch to cohort size = \code{cohortsize}.
#' Titration accelerates the dose escalation and is useful when low doses are believed to be safe.
#'
#' When selecting the next dose in escalation/de-escalation, the dose with higher posterior
#' probability of being in the optimal interval is selected as the next dose.
#' When the posterior probability of the two candidate doses being in the
#' optimal interval is equal or both candidate doses have no data, the next
#' dose is selected according to the preference matrix. When one candidate dose
#' has data, the other has not, the next dose is the candidate dose with no data.
#'
#'
#' The BOIN-CombP design has two built-in stopping rules:
#' (1) stop the trial/subtrial if the lowest dose is eliminated due to toxicity, and no dose should
#' be selected as the MTD; and (2) stop the trial/subtrial and select the MTD if the number of
#' patients treated at the current dose reaches \code{n.earlystop}. The first stopping rule is a safety
#' rule to protect patients from the case in which all doses are overly toxic. The rationale for
#' the second stopping rule is that when there is a large number (i.e., \code{n.earlystop}) of
#' patients assigned to a dose, it means that the dose-finding algorithm has approximately converged.
#' Thus, we can stop the trial/subtrial early and select the MTD to save sample size and reduce the
#' trial duration.
#'
#'
#'  For some applications, investigators may prefer a more strict safety stopping rule than rule
#'  (1) for extra safety when the lowest dose is overly toxic.
#'  This can be achieved by setting \code{extrasafe=TRUE},
#'  which imposes the following more strict safety stopping rule:
#'  stop the trial if (i) the number of patients treated at the lowest dose \code{>=3},
#' and (ii) \eqn{Pr(toxicity\ rate\ of\ the\ lowest\ dose > \code{target} | data) > \code{cutoff.eli}-\code{offset}}.
#' As a tradeoff, the strong stopping rule will decrease the MTD selection percentage
#'  when the lowest dose actually is the MTD.
#'
#' @return \code{get.oc.combP()} returns the operating characteristics of the BOIN combination or
#' waterfall design as a list. For the BOIN combination design, including:
#' (1) true toxicity probability at each dose level (\code{$p.true}),
#' (2) preference at each dose level (\code{$preferred.doses}),
#' (3) selection percentage at each dose level (\code{$selpercent}),
#' (4) the number of patients treated at each dose level (\code{$npatients})
#' (5) the number of toxicities observed at each dose level (\code{$ntox}),
#' (6) the total number of patients in the trial (\code{$totaln}),
#' (7) the total number of toxicities observed for the trial (\code{$totaltox})
#' (8) the percentage of correct selection (\code{$pcs}),
#' (9) the percentage of acceptable selection (\code{$pas}),
#' (10) the total percentage of patients treated at the MTD (\code{$npercent}).
#' (11) the percentage of early stopping without selecting the MTD (\code{$percentstop})
#'
#'
#' @note We should avoid setting the values of \code{p.saf} and \code{p.tox} very close to the
#'      \code{target}. This is because the small sample sizes of typical phase I trials prevent us from
#'       differentiating the target DLT rate from the rates close to it. The default values provided by
#'       \code{get.oc()} are strongly recommended, and generally yield excellent operating characteristics.
#'
#'
#' @author Yuxuan Chen, Haiming Zhou, and Philip He.
#'
#' @references Liu S. and Yuan, Y. (2015). Bayesian Optimal Interval Designs for Phase I Clinical
#'             Trials, \emph{Journal of the Royal Statistical Society: Series C}, 64, 507-523.
#'
#'            Lin R. and Yin, G. (2017). Bayesian Optimal Interval Designs for Dose Finding in
#'            Drug-combination Trials, \emph{Statistical Methods in Medical Research}, 26, 2155-2167.
#'
#'            Yan, F., Zhang, L., Zhou, Y., Pan, H., Liu, S. and Yuan, Y. (2020).BOIN: An R Package
#'            for Designing Single-Agent and Drug-Combination Dose-Finding Trials Using Bayesian Optimal
#'            Interval Designs. \emph{Journal of Statistical Software}, 94(13),1-32.<doi:10.18637/jss.v094.i13>.
#'
#'
#'            Zhang L. and Yuan, Y. (2016). A Simple Bayesian Design to Identify the Maximum
#'            Tolerated Dose Contour for Drug Combination Trials, \emph{Statistics in Medicine}, 35, 4924-4936.
#'
#' @examples
#'
#' ###### drug-combination trial ######
#'
#' ##### combination trial to find a single MTD  ######
#'
#'S1.p.true <- matrix(c(0.02, 0.07, 0.10,
#'0.07, 0.10, 0.15,
#'0.10, 0.15, 0.30,
#'0.15, 0.30, 0.45,
#'0.30, 0.45, 0.55), nrow = 3, byrow = FALSE)
#'doses.cp <- matrix(c(1, 1, 1, 1, 1,
#'                     1, 1,  1, 1, 1,
#'                     1, 1, 1, 1, 1),
#'                   ncol = 5, byrow = TRUE)
#'
#'## combo version
#'# prior
#'## drug 1
#'mean1 <- c(-1.0989, -0.1674)
#'se1 <- c(1.2770, 0.5713)
#'corr1 <- 0.5224
#'prior1 <- list(mean=mean1, se=se1, corr=corr1)
#'## drug 2
#'mean2 <- c(-2.9444, 0)
#'se2 <- c(2, 1)
#'corr2 <- 0
#'prior2 <- list(mean=mean2, se=se2, corr=corr2)
#'##'interaction between 2 drugs
#'prior3 <- list(mean=0, se=1.121)
#'##'combine three sets of priors
#'prior <- list(prior1, prior2, prior3)
#'
#'#'parameters
#'seeds <- 1:2
#'nsamples <- 10000
#'burn_in <- 0.5
#'
#'##'drug 1
#'drug1_name <- "DRUG-X"
#'dose1_unit <- "mg"
#'ref_dose1 <- 5
#'prov_dose1 <- c(1, 2.5, 5)
#'
#'##'drug 2
#'drug2_name <- "DRUG-Y"
#'dose2_unit <- "mg"
#'ref_dose2 <- 400
#'prov_dose2 <- c(200, 250, 300, 350, 400)
#'
#'category_bound <- c(0.16, 0.33)
#'category_name <- c("under-dosing", "targeted-toxicity", "over-dosing")
#'ewoc <- 0.30
#'
#'#'combine to a list
#'BLRMspecs <- list(seeds=seeds, nsamples=nsamples, burn_in=burn_in,
#'                  drug1_name=drug1_name, dose1_unit=dose1_unit,
#'                  ref_dose1=ref_dose1, prov_dose1=prov_dose1,
#'                  drug2_name=drug2_name, dose2_unit=dose2_unit,
#'                  ref_dose2=ref_dose2, prov_dose2=prov_dose2,
#'                  #'dose1=dose1, dose2=dose2, n_pat=n_pat, dlt=dlt,
#'                  category_bound=category_bound, category_name=category_name,
#'                  ewoc=ewoc,
#'                  prior=prior)
#'
#'
#'oc.comb <- get.oc.combBB.parallel(BLRMspecs, target=0.3, p.true=S1.p.true, ncohort=10, cohortsize=3,
#'                         preferred.doses = doses.cp, n.earlystop=9, startdose=c(1,1), ntrial=1000, nCore=5)
#'
#'summary(oc.comb)
#'
#' @importFrom parallel detectCores makeCluster parLapply stopCluster
#' @import BOIN
#' @import stats
#' @import blrm
#' @export


get.oc.combBB.parallel <- function (BLRMspecs, target, p.true, ncohort, cohortsize, preferred.doses, n.earlystop = NULL,
                             startdose = c(1, 1), titration = FALSE, p.saf = 0.6 * target,
                             p.tox = 1.4 * target, cutoff.eli = 0.95, extrasafe = FALSE,
                             offset = 0.05, ntrial = 1000, mtd.contour = FALSE, boundMTD=FALSE,
                             explore_deescalation=FALSE,
                             seed=123, nCore=NULL)
{

  ## Start simulation
  if(is.null(nCore)){
    nCore = max(parallel::detectCores()-4, 5)
  }
  #nsim_per_cluster <- 1000
  cl <- parallel::makeCluster(nCore, type = "PSOCK")
  doParallel::registerDoParallel(cl)

  nsim_per_cluster = ceiling(ntrial/nCore)

  if(length(seed==1)) seed=(1:nCore)*seed
  else if(length(seed)!=nCore) stop("The number of seeds should match the number of cores")


  translate_cohorts <- function(prov_dose1, prov_dose2, y, n) {
    dose1 <- numeric(0)
    dose2 <- numeric(0)
    dlt <- integer(0)
    n_pat <- integer(0)

    for (i in seq_along(prov_dose1)) {
      for (j in seq_along(prov_dose2)) {
        if (n[i, j] > 0) {
          dose1 <- c(dose1, prov_dose1[i])
          dose2 <- c(dose2, prov_dose2[j])
          dlt <- c(dlt, y[i, j])
          n_pat <- c(n_pat, n[i, j])
        }
      }
    }

    return(list(dose1 = dose1, dose2 = dose2, dlt = dlt, n_pat = n_pat))
  }
  find_immediate_neighbors <- function(prov_dose1, prov_dose2, current_position, escalate=TRUE) {
    # Create dose grid
    dose_grid <- expand.grid(prov_dose1, prov_dose2)

    # Get unique sorted dose levels
    dose_levels1 <- sort(unique(prov_dose1))
    dose_levels2 <- sort(unique(prov_dose2))

    # Extract current dose based on position
    dose1 <- dose_levels1[current_position[1]]
    dose2 <- dose_levels2[current_position[2]]

    # Find the next immediate levels
    if(escalate){
      next_dose1 <- ifelse(current_position[1] < length(dose_levels1), dose_levels1[current_position[1] + 1], NA)
      next_dose2 <- ifelse(current_position[2] < length(dose_levels2), dose_levels2[current_position[2] + 1], NA)
    }else{
      next_dose1 <- ifelse(current_position[1] > 1, dose_levels1[current_position[1] - 1], NA)
      next_dose2 <- ifelse(current_position[2] > 1, dose_levels2[current_position[2] - 1], NA)
    }


    # Identify immediate neighboring dose pairs and return row indices
    neighbor_rows <- which((dose_grid$Var1 == next_dose1 & dose_grid$Var2 == dose2) |
                             (dose_grid$Var2 == next_dose2 & dose_grid$Var1 == dose1))

    return(neighbor_rows)
  }
  blrm_combo_ss_local <- function (prior, data, output_excel = FALSE, output_pdf = FALSE)
  {
    tox_prob <- function(d1, d2, param) {
      logit_pi1 <- log(param[1]) + param[2] * d1
      pi1 <- exp(logit_pi1)/(1 + exp(logit_pi1))
      logit_pi2 <- log(param[3]) + param[4] * d2
      pi2 <- exp(logit_pi2)/(1 + exp(logit_pi2))
      odds_pi12 <- exp(param[5] * exp(d1) * exp(d2)) * (pi1 +
                                                          pi2 - pi1 * pi2)/((1 - pi1) * (1 - pi2))
      pi12 <- odds_pi12/(1 + odds_pi12)
      return(list(pi1 = pi1, pi2 = pi2, pi12 = pi12))
    }
    prior_summary <- function(prior) {
      prior.drug1 <- prior[[1]]
      prior.drug2 <- prior[[2]]
      prior.inter <- prior[[3]]
      mean1 <- prior.drug1[[1]]
      se1 <- prior.drug1[[2]]
      corr1 <- prior.drug1[[3]]
      mean2 <- prior.drug2[[1]]
      se2 <- prior.drug2[[2]]
      corr2 <- prior.drug2[[3]]
      mean3 <- prior.inter[[1]]
      se3 <- prior.inter[[2]]
      covariance_matrix1 <- matrix(c(se1[1]^2, se1[1] * se1[2] *
                                       corr1, se1[1] * se1[2] * corr1, se1[2]^2), ncol = 2,
                                   byrow = T)
      covariance_matrix2 <- matrix(c(se2[1]^2, se2[1] * se2[2] *
                                       corr2, se2[1] * se2[2] * corr2, se2[2]^2), ncol = 2,
                                   byrow = T)
      return(list(prior1 = list(mean1, covariance_matrix1),
                  prior2 = list(mean2, covariance_matrix2), prior3 = list(mean3,
                                                                          se3^2)))
    }
    single_cohort <- function() {
      mydata <- list(nb_pat = sum(cohort_size), s = data_dlt,
                     d1 = data_sdose1, d2 = data_sdose2, p1 = prior_para$prior1[[1]],
                     p2 = prior_para$prior1[[2]], p3 = prior_para$prior2[[1]],
                     p4 = prior_para$prior2[[2]], p5 = prior_para$prior3[[1]],
                     p6 = prior_para$prior3[[2]])
      niters <- (1 + burn_in) * nsamples/2
      modelstring <- "model\n    {\n    Omega1[1:2,1:2] <- inverse(p2[,])\n    log.alpha[1:2] ~ dmnorm(p1[], Omega1[,])\n    \n    Omega2[1:2,1:2] <- inverse(p4[,])\n    log.alpha[3:4] ~ dmnorm(p3[], Omega2[,])\n    \n    tau <- 1/p6\n    eta ~ dnorm(p5, tau)\n    \n    alpha[1] <- exp(log.alpha[1])\n    alpha[2] <- exp(log.alpha[2])\n    alpha[3] <- exp(log.alpha[3])\n    alpha[4] <- exp(log.alpha[4])\n    \n    for(i in 1:nb_pat){\n    logit(pi1[i]) <- log.alpha[1] + alpha[2] * d1[i]\n    logit(pi2[i]) <- log.alpha[3] + alpha[4] * d2[i]\n    odds_pi12[i] <- exp(eta * exp(d1[i]) * exp(d2[i])) * (pi1[i] + pi2[i] - pi1[i] * pi2[i])/((1 - pi1[i]) * (1 - pi2[i]))\n    pi12[i] <- odds_pi12[i]/(1 + odds_pi12[i])\n    s[i] ~ dbern(pi12[i])\n    }\n    }"
      inits.list <- list(list(log.alpha = c(-3, 0, -3, 0),
                              eta = 0, .RNG.seed = seeds[1], .RNG.name = "base::Wichmann-Hill"),
                         list(log.alpha = c(-3, 0, -3, 0), eta = 0, .RNG.seed = seeds[2],
                              .RNG.name = "base::Wichmann-Hill"))
      jagsobj <- rjags::jags.model(textConnection(modelstring),
                                   data = mydata, n.chains = 2, quiet = TRUE, inits = inits.list)
      update(jagsobj, n.iter = niters, progress.bar = "none")
      res <- rjags::jags.samples(jagsobj, c("alpha", "eta"),
                                 n.iter = niters, progress.bar = "none")
      alpha1 <- res$alpha[1, , ][-c(1:(burn_in * nsamples/2)),
      ]
      beta1 <- res$alpha[2, , ][-c(1:(burn_in * nsamples/2)),
      ]
      alpha2 <- res$alpha[3, , ][-c(1:(burn_in * nsamples/2)),
      ]
      beta2 <- res$alpha[4, , ][-c(1:(burn_in * nsamples/2)),
      ]
      eta <- res$eta[1, , ][-c(1:(burn_in * nsamples/2)),
      ]

      # # Convert to coda's mcmc.list format for diagnostics
      #
      # samples_list <- mcmc.list(
      #   mcmc(cbind(
      #     alpha1 = res$alpha[1,,1],
      #     beta1 = res$alpha[2,,1],
      #     alpha2 = res$alpha[3,,1],
      #     beta2 = res$alpha[4,,1],
      #     eta = res$eta[,,1]
      #   )),
      #   mcmc(cbind(
      #     alpha1 = res$alpha[1,,2],
      #     beta1 = res$alpha[2,,2],
      #     alpha2 = res$alpha[3,,2],
      #     beta2 = res$alpha[4,,2],
      #     eta = res$eta[,,2]
      #   ))
      # )
      #
      # # --- Convergence Diagnostics ---
      # cat("\n--- Convergence Diagnostics ---\n")
      #
      # # 1. Trace plots
      # try(traceplot(samples_list), silent = TRUE)  # Wrap in try() to prevent crashes
      #
      # # 2. Gelman-Rubin Diagnostic
      # gelman <- gelman.diag(samples_list, multivariate = FALSE)
      # cat("Gelman-Rubin Diagnostic (PSRF ~1):\n")
      # print(gelman)
      #
      # # 3. Geweke Diagnostic
      # geweke_z <- geweke.diag(samples_list)
      # cat("\nGeweke Z-scores (|z| <1.96):\n")
      # print(geweke_z)
      #
      # # 4. Raftery-Lewis Burn-in Estimation
      # raf <- raftery.diag(samples_list)
      # burn_in_needed <- max(sapply(raf, function(x) max(x$resmatrix[,"M"])))  # Key fix here
      # cat("\nRaftery-Lewis Suggested Burn-in:", burn_in_needed, "\n")
      #
      # # 5. Heidelberger-Welch Stationarity
      # heidel <- heidel.diag(samples_list)
      # cat("\nHeidelberger-Welch Stationarity:\n")
      # print(heidel)
      #
      # # Determine final burn-in to use
      # burn_in_final <- max(burn_in_needed, burn_in * nsamples/2)
      # if(burn_in_final >= dim(res$alpha)[2]) {
      #   warning("Suggested burn-in exceeds chain length! Keeping all samples")
      #   burn_in_final <- 0
      # }
      # keep_samples <- (burn_in_final + 1):dim(res$alpha)[2]
      #
      # # --- Apply burn-in to all parameters ---
      # alpha1 <- res$alpha[1, keep_samples, ]
      # beta1 <- res$alpha[2, keep_samples, ]
      # alpha2 <- res$alpha[3, keep_samples, ]
      # beta2 <- res$alpha[4, keep_samples, ]
      # eta <- res$eta[1, keep_samples, ]

      posterior_param <- cbind(c(alpha1), c(beta1), c(alpha2),
                               c(beta2), c(eta))
      log_para <- apply(posterior_param[, 1:4], 2, log)
      log_para <- cbind(log_para, posterior_param[, 5])
      para_hat <- apply(log_para, 2, mean)
      para_sd <- apply(log_para, 2, sd)
      para_corr1 <- boot::corr(log_para[, 1:2])
      para_corr2 <- boot::corr(log_para[, 3:4])
      posterior_para_summary <- list(para_hat = para_hat,
                                     para_sd = para_sd, para_corr1 = para_corr1, para_corr2 = para_corr2)
      samples_sdose <- matrix(0, nprov_dose, nsamples)
      for (i in 1:nprov_dose) {
        for (j in 1:nsamples) {
          samples_sdose[i, j] <- tox_prob(sprov_dose[i,
                                                     1], sprov_dose[i, 2], posterior_param[j, ])$pi12
        }
      }
      posterior_prob_summary <- matrix(0, length(category_bound) +
                                         1, nprov_dose)
      for (i in 1:nprov_dose) {
        posterior_prob_summary[, i] <- as.numeric(table(cut(samples_sdose[i,
        ], breaks = c(0, category_bound[1], category_bound[2],
                      1), right = TRUE))/nsamples)
      }
      posterior_pi_summary <- matrix(0, 5, nprov_dose)
      for (i in 1:nprov_dose) {
        posterior_pi_summary[, i] <- c(mean(samples_sdose[i,
        ]), sd(samples_sdose[i, ]), quantile(samples_sdose[i,
        ], c(0.025, 0.5, 0.975)))
      }
      safe_dose_range <- (posterior_prob_summary[3, ] <= ewoc)
      if (sum(safe_dose_range) != 0) {
        posterior_prob_summary <- as.data.frame(posterior_prob_summary)
        posterior_pi_summary <- as.data.frame(posterior_pi_summary)
        names(posterior_prob_summary) <- paste(1:nrow(prov_dose))
        names(posterior_pi_summary) <- names(posterior_prob_summary)
        next_dose_index <- as.numeric(names(which.max(posterior_prob_summary[2,
                                                                             safe_dose_range])))
        next_dose_level <- prov_dose[next_dose_index, ]
        next_dose_posterior_prob_summary <- posterior_prob_summary[,
                                                                   next_dose_index]
        next_dose_posterior_pi_summary <- posterior_pi_summary[,
                                                               next_dose_index]
        next_dose <- list(index = next_dose_index, dose = next_dose_level,
                          posterior_prob_summary = list(next_dose_posterior_prob_summary),
                          posterior_pi_summary = list(next_dose_posterior_pi_summary))
      }
      else {
        next_dose <- NULL
      }
      posterior_prob_summary <- as.matrix(posterior_prob_summary)
      posterior_pi_summary <- as.matrix(posterior_pi_summary)
      return(list(posterior_prob_summary = posterior_prob_summary,
                  posterior_para_summary = posterior_para_summary,
                  posterior_pi_summary = posterior_pi_summary, next_dose = next_dose))
    }
    prior_para <- prior_summary(prior)
    seeds <- data$seeds
    nsamples <- data$nsamples
    burn_in <- data$burn_in
    n_pat <- data$n_pat
    dlt_test <- data$dlt
    ewoc <- data$ewoc
    category_bound <- data$category_bound
    category_name <- data$category_name
    drug1_name <- data$drug1_name
    prov_dose1 <- data$prov_dose1
    ref_dose1 <- data$ref_dose1
    dose1_unit <- data$dose1_unit
    dose1 <- data$dose1
    drug2_name <- data$drug2_name
    prov_dose2 <- data$prov_dose2
    ref_dose2 <- data$ref_dose2
    dose2_unit <- data$dose2_unit
    dose2 <- data$dose2
    sdose1 <- log(dose1/ref_dose1)
    sdose2 <- log(dose2/ref_dose2)
    sdose <- cbind(sdose1, sdose2)
    ndose1 <- length(sdose1)
    ndose2 <- length(sdose2)
    ndose <- nrow(sdose)
    prov_dose <- expand.grid(prov_dose1, prov_dose2)
    sprov_dose <- expand.grid(log(prov_dose1/ref_dose1), log(prov_dose2/ref_dose2))
    nprov_dose1 <- length(prov_dose1)
    nprov_dose2 <- length(prov_dose2)
    nprov_dose <- nrow(prov_dose)
    current_dose_index <- 1
    dose_index <- cohort_size <- dlt <- NULL
    data_sdose1 <- data_sdose2 <- data_dlt <- NULL
    cohort_all <- list()
    t <- 1
    while (current_dose_index <= ndose) {
      current_cohort_size <- n_pat[current_dose_index]
      current_dlt <- dlt_test[current_dose_index]
      dose_index <- c(dose_index, current_dose_index)
      cohort_size <- c(cohort_size, current_cohort_size)
      dlt <- c(dlt, current_dlt)
      current_data_sdose1 <- rep(sdose[current_dose_index,
                                       1], current_cohort_size)
      current_data_sdose2 <- rep(sdose[current_dose_index,
                                       2], current_cohort_size)
      data_sdose1 <- c(data_sdose1, current_data_sdose1)
      data_sdose2 <- c(data_sdose2, current_data_sdose2)
      current_data_dlt <- ifelse(rep(current_dlt == 0, current_cohort_size),
                                 rep(0, current_cohort_size), c(rep(1, current_dlt),
                                                                rep(0, current_cohort_size - current_dlt)))
      data_dlt <- c(data_dlt, current_data_dlt)
      cohort <- single_cohort()
      cohort_all[[current_dose_index]] <- list(dose_index = dose_index,
                                               cohort_size = cohort_size, dlt = dlt, posterior_prob = cohort$posterior_prob_summary,
                                               posterior_para = cohort$posterior_para_summary,
                                               posterior_pi = cohort$posterior_pi_summary, next_dose = cohort$next_dose)
      if (is.null(cohort$next_dose)) {
        break
      }
      else {
        current_dose_index <- current_dose_index + 1
      }
      cat("tested drug combination ", t, " is done.\n", sep = "")
      t <- t + 1
    }
    cohort_final <- cohort_all[[length(cohort_all)]]
    prob_posterior <- cohort_final$posterior_prob
    pi_posterior <- cohort_final$posterior_pi
    para_posterior <- cohort_final$posterior_para
    next_dose <- cohort_final$next_dose
    return(list(prob_posterior = prob_posterior, para_posterior = para_posterior,
                pi_posterior = pi_posterior, next_dose = next_dose,
                cohort_all = cohort_all))
  }

  get.oc.comb.boin.blrm <- function(seed=123, BLRMspecs, target, p.true, ncohort, cohortsize, preferred.doses,
                                    n.earlystop = 100, startdose = c(1, 1), titration = FALSE,
                                    p.saf = 0.6 * target, p.tox = 1.4 * target, cutoff.eli = 0.95,
                                    extrasafe = FALSE, offset = 0.05, boundMTD=FALSE, explore_deescalation=FALSE,
                                    ntrial = 1000) {
    set.seed(seed)
    prov_dose = expand.grid(BLRMspecs$prov_dose1, BLRMspecs$prov_dose2)
    JJ = nrow(p.true)
    KK = ncol(p.true)
    if (JJ > KK)
      stop("p.true should be arranged in a way (i.e., rotated) such that\n          the number of rows is less than or equal to the number of columns.")
    if (JJ > KK)
      p.true = t(p.true)
    if (target < 0.05) {
      stop("the target is too low!")
    }
    if (target > 0.6) {
      stop("the target is too high!")

    }
    if ((target - p.saf) < (0.1 * target)) {
      stop("the probability deemed safe cannot be higher than or too close to the target!")
    }
    if ((p.tox - target) < (0.1 * target)) {
      stop("the probability deemed toxic cannot be lower than or too close to the target!")
    }
    if (offset >= 0.5) {
      stop("the offset is too large!")
    }
    if (n.earlystop <= 6) {
      warning("the value of n.earlystop is too low to ensure good operating characteristics. Recommend n.earlystop = 9 to 18")
    }
    if (preferred.doses[startdose[1], startdose[2]]!=1){
      stop("Start dose must be preferred dose!")
    }
    ndose = length(p.true)
    npts = ncohort * cohortsize
    Y <- array(matrix(rep(0, length(p.true) * ntrial), dim(p.true)[1]),
               dim = c(dim(p.true), ntrial))
    N <- array(matrix(rep(0, length(p.true) * ntrial), dim(p.true)[1]),
               dim = c(dim(p.true), ntrial))
    dselect = matrix(rep(0, 2 * ntrial), ncol = 2) # selected dose default set to 0

    ## get boundary parameters -------------------------------------------------
    if (cohortsize > 1) {
      temp = get.boundary(target, ncohort, cohortsize,
                          n.earlystop=ncohort*cohortsize, p.saf, p.tox, cutoff.eli, extrasafe)$full_boundary_tab
    }else {
      temp = get.boundary(target, ncohort, cohortsize,
                          n.earlystop=ncohort*cohortsize, p.saf, p.tox, cutoff.eli, extrasafe)$boundary_tab
    }
    b.e = temp[2, ]
    b.d = temp[3, ]
    b.elim = temp[4, ]
    lambda1 = log((1 - p.saf)/(1 - target))/log(target *
                                                  (1 - p.saf)/(p.saf * (1 - target)))
    lambda2 = log((1 - target)/(1 - p.tox))/log(p.tox * (1 -
                                                           target)/(target * (1 - p.tox)))


    if (cohortsize == 1)
      titration = FALSE

    # simulation trials -------------------------------------------------------
    for (trial in 1:ntrial) {
      # cat("i_trial:",trial,"\n")
      if(trial==33){
        xx=1
      }
      y <- matrix(rep(0, ndose), dim(p.true)[1], dim(p.true)[2]) # DLT patients
      n <- matrix(rep(0, ndose), dim(p.true)[1], dim(p.true)[2]) # patients treated
      earlystop = 0 # flag for elimination stop
      d = startdose
      elimi = matrix(rep(0, ndose), dim(p.true)[1], dim(p.true)[2])
      elimi = elimi + (preferred.doses==-1) # not considered doses are flagged as eliminate
      ft=TRUE #flag used to determine whether or not to add cohortsize-1 patients to a dose for the first time when titration is triggered.
      if (titration) {
        tmpa = d[1]
        tmpb = d[2]
        y[tmpa, tmpb] <- (runif(1) < p.true[tmpa, tmpb])
        n[tmpa, tmpb] <- 1
        while (tmpa <= dim(p.true)[1] & tmpb <= dim(p.true)[2]) {
          if (tmpa == dim(p.true)[1] & tmpb == dim(p.true)[2]) {
            break
          }
          if (sum(y) == 1) {
            y[tmpa, tmpb] = 1
            break
          }
          if (tmpa < dim(p.true)[1] & tmpb < dim(p.true)[2]) {
            tmp.candidate = rbind(c(tmpa + 1, tmpb),
                                  c(tmpa, tmpb + 1))
            tmp.sel = rbinom(1, 1, prob = c(0.5, 0.5)) +
              1
            tmpa = tmp.candidate[tmp.sel, 1]
            tmpb = tmp.candidate[tmp.sel, 2]
          }
          else if (tmpa == dim(p.true)[1]) {
            tmpb = tmpb + 1
          }
          else {
            tmpa = tmpa + 1
          }
          y[tmpa, tmpb] <- (runif(1) < p.true[tmpa, tmpb])
          n[tmpa, tmpb] <- 1
        }
        if (sum(y) == 0) {
          d = c(dim(p.true)[1], dim(p.true)[2])
        }
        else {
          d = c(tmpa, tmpb)
        }
      }
      for (pp in 1:ncohort) {

        ## generate DLT for enrolled patient in this cohort -----------------------
        if (titration & n[d[1], d[2]] < cohortsize & ft) {
          ft=FALSE

          y[d[1], d[2]] = y[d[1], d[2]] + sum(runif(cohortsize -
                                                      1) < p.true[d[1], d[2]])
          n[d[1], d[2]] = n[d[1], d[2]] + cohortsize -1
        }
        else {
          y[d[1], d[2]] = y[d[1], d[2]] + sum(runif(cohortsize) <
                                                p.true[d[1], d[2]])
          n[d[1], d[2]] = n[d[1], d[2]] + cohortsize
        }



        nc = n[d[1], d[2]] #the updated number of patients treated for this dose

        ## examine elimination -------------------------------------------------
        if (!is.na(b.elim[nc])) { # if eliminated boundary exists

          if (y[d[1], d[2]] >= b.elim[nc]) { # if number of DLTs in current dose exceeds elimination boundary


            for (i in min(d[1], dim(p.true)[1]):dim(p.true)[1]) { # set elimination status for current and higher dose to 1
              for (j in min(d[2], dim(p.true)[2]):dim(p.true)[2]) {
                elimi[i, j] = 1
              }
            }

            if (d[1] == 1 && d[2] == 1) { # if current dose is lowest dose, early stop
              d = c(99, 99)
              earlystop = 1
              break
            }
          }


          if (extrasafe) {
            if (d[1] == 1 && d[2] == 1 && n[1, 1] >=
                3) {
              if (1 - pbeta(target, y[1, 1] + 1, n[1,
                                                   1] - y[1, 1] + 1) > cutoff.eli - offset) {
                d = c(99, 99)
                earlystop = 1
                break
              }
            }
          }
        }

        ## check if need to stop the trial ----------------------------------------
        if (n[d[1],d[2]] >= n.earlystop  &&  # MUST: current dose reach early stop cohort size and satisfy one of the following:
            (y[d[1],d[2]]>b.e[n[d[1],d[2]]] || #  current dose reach elimination boundary
             (d[1]==dim(p.true)[1] && d[2]==dim(p.true)[2]) || #  current dose is highest dose
             ( d[1]==dim(p.true)[1] && d[2]<dim(p.true)[2] && elimi[d[1],d[2]+1]==1 ) || # higher dose eliminated in one direction, current dose reach highest dose in one drug
             ( d[1]<dim(p.true)[1] && d[2]==dim(p.true)[2] && elimi[d[1]+1,d[2]]==1 ) ||
             ( d[1]<dim(p.true)[1] && d[2]<dim(p.true)[2] && elimi[d[1]+1,d[2]]==1 && elimi[d[1],d[2]+1]==1 ) )  && # higher dose eliminated in both directions
            (y[d[1],d[2]]<b.d[n[d[1],d[2]]] || (d[1]==1 && d[2]==1) ) ) break; # MUST: DLTs below de-escalation boundary or current dose is the lowest dose


        ## escalate ---------------------------------
        if (y[d[1], d[2]] <= b.e[nc]) {
          if(d[1]==dim(p.true)[1] && d[2] < dim(p.true)[2] ){ # if reach boundary in one direction
            d = d + c(0,1)*( preferred.doses[d[1],d[2]+1]>=0)
          }else if (d[1]<dim(p.true)[1] && d[2] == dim(p.true)[2]){ # if reach boundary in one direction
            d = d + c(1,0)*( preferred.doses[d[1]+1,d[2]]>=0)
          }else{
            elevel = matrix(c(1, 0, 0, 1), 2) # Two potential escalation directions
            pr_H0 = rep(0, length(elevel)/2) # to store probabilities for two potential dose
            nn = yn = pr_H0 # store number of patients treated at each candidate dose and number of DLT
            prefer = rep(0, length(elevel)/2) # to store preference for two candidate dose
            for (i in seq(1, length(elevel)/2, by = 1)) { # check for two candidates
              if (d[1] + elevel[1, i] <= dim(p.true)[1] && # check if candidate dose is within the dose matrix
                  d[2] + elevel[2, i] <= dim(p.true)[2]) {
                prefer[i] = preferred.doses[d[1] + elevel[1, i], d[2] + elevel[2, i]]
                if (elimi[d[1] + elevel[1, i], d[2] + elevel[2,
                                                             i]] == 0) { # if candidate has not been eliminated
                  yn[i] = y[d[1] + elevel[1, i], d[2] + elevel[2,
                                                               i]] # observed DLTs at candidate dose
                  nn[i] = n[d[1] + elevel[1, i], d[2] +
                              elevel[2, i]] # observed number of patients at candidate dose
                  pr_H0[i] <- pbeta(lambda2, yn[i] + 0.5, nn[i] - yn[i] + 0.5) -
                    pbeta(lambda1, yn[i] + 0.5, nn[i] - yn[i] + 0.5) # prob of within target DLT boundary


                }
              }
            }

            pr_H0 = pr_H0 + nn * 5e-04 + ifelse(prefer==-1, -99,0) # negative prob for not considered dose # avoid zero prob if candidate dose have patients
            if (max(pr_H0) <= 0) { ##!!! no valid escalation if both not considered or both outside of dose matrix
              d = d
            }else { ## select candidate dose based on preference and posterior prob
              if(min(prefer)<0){ # if one dose not considered, go to the other dose
                k = which.max(prefer)
                d = d + c(elevel[1, k], elevel[2, k])
              }else{ ## BLRM to calculate probability
                print(n)
                print(y)
                cat("current dose considered for escalation:", d, "\n")
                tested_dose <- translate_cohorts(BLRMspecs$prov_dose1, BLRMspecs$prov_dose2, y, n)
                BLRMdata <- c(BLRMspecs, tested_dose)
                blrm_trial <- blrm_combo_ss_local(prior=BLRMspecs$prior, data=BLRMdata, output_excel=FALSE, output_pdf=FALSE)
                candidate_dose = find_immediate_neighbors(BLRMspecs$prov_dose1, BLRMspecs$prov_dose2, d)
                candidate_prob_posterior = blrm_trial$prob_posterior[2, candidate_dose]
                next.dose <- prov_dose[candidate_dose[which.max(candidate_prob_posterior)],]
                d = c(which(BLRMspecs$prov_dose1==next.dose$Var1), which(BLRMspecs$prov_dose2==next.dose$Var2))
                cat("BLRM recommended dose for escalation:", d, "\n")
              }
              #   if(prefer[1] != prefer[2]){ # one prefered, one low priority
              #   if(max(nn)==0 || min(pr_H0)==max(pr_H0)){ k = which.max(prefer)} # if both have no data or have equal prob, go to the preferred dose
              #   else if(min(nn)>0){ k = which.max(pr_H0)} # if both have data and not equal prob, go to higher prob
              #   else if(max(nn)>0 & min(nn)==0){ # if one has data, the other has not
              #     if(yn[which.max(nn)] <= b.e[nn]){k = 1+round(runif(1))} # not toxic, random
              #     else if(yn[which.max(nn)] >= b.d[nn]){k = which.min(nn)} # toxic go to the other dose
              #     }
              # }else if(prefer[1] == prefer[2]){ # same priority
              #   if(max(nn)==0 || min(pr_H0)==max(pr_H0)){ k = 1+round(runif(1))} # if both have no data or have equal prob, random pick with equal allocation
              #   else if(min(nn)>0){ k = which.max(pr_H0)} # if both have data and not equal prob, go to higher prob
              #   else if(max(nn)>0 & min(nn)==0){ k = which.min(nn)} # if one has data, the other has not, go to the one has no data
              #
              # }
              # d = d + c(elevel[1, k], elevel[2, k])
            }
          }
        }
        ## de-escalate ----------------------------
        else if (y[d[1], d[2]] >= b.d[nc]) {

          if(d[1]==1 && d[2] > 1 ){ # if reach boundary in one direction
            d = d + c(0,-1)*( preferred.doses[d[1],d[2]-1]>=0)
          }else if (d[1]>1 && d[2] == 1){ # if reach boundary in one direction
            d = d + c(-1,0)*( preferred.doses[d[1]-1,d[2]]>=0)
          }else{
            delevel = matrix(c(-1, 0, 0, -1), 2)
            pr_H0 = rep(0, length(delevel)/2)
            nn = yn = pr_H0
            prefer = rep(0, length(elevel)/2) # to store preference for two candidate dose
            for (i in seq(1, length(delevel)/2, by = 1)) {
              if (d[1] + delevel[1, i] > 0 && d[2] + delevel[2,
                                                             i] > 0) {
                yn[i] = y[d[1] + delevel[1, i], d[2] + delevel[2,
                                                               i]]
                nn[i] = n[d[1] + delevel[1, i], d[2] +
                            delevel[2, i]]
                pr_H0[i] = pbeta(lambda2, yn[i] + 0.5, nn[i] - yn[i] + 0.5) -
                  pbeta(lambda1, yn[i] + 0.5, nn[i] - yn[i] + 0.5)

                prefer[i] = preferred.doses[d[1] + delevel[1, i], d[2] + delevel[2, i]]
              }
            }

            pr_H0 = (pr_H0 + nn * 5e-04) + ifelse(prefer==-1, -99,0) # negative prob for not considered dose

            if (max(pr_H0) <= 0) { # for dose with no de-escalation option
              d = d
            }else if(explore_deescalation && sum(nn==0)>0){ # explore the untested dose in de-escalation
              k = which(nn==0)[1]
              d = d + c(delevel[1, k], delevel[2, k])
            }else {
              ## select candidate dose based on preference and posterior prob
              if(min(prefer)<0){ # if one dose not considered, go to the other dose
                k = which.max(prefer)
                d = d + c(delevel[1, k], delevel[2, k])
              }else { ## BLRM to calculate probability
                print(n)
                print(y)
                cat("current dose considered for de-escalation:", d, "\n")
                tested_dose <- translate_cohorts(BLRMspecs$prov_dose1, BLRMspecs$prov_dose2, y, n)
                BLRMdata <- c(BLRMspecs, tested_dose)
                blrm_trial <- blrm_combo_ss_local(prior=BLRMspecs$prior, data=BLRMdata, output_excel=FALSE, output_pdf=FALSE)
                candidate_dose = find_immediate_neighbors(BLRMspecs$prov_dose1, BLRMspecs$prov_dose2, d, escalate=FALSE)
                candidate_prob_posterior = blrm_trial$prob_posterior[2, candidate_dose]
                next.dose <- prov_dose[candidate_dose[which.max(candidate_prob_posterior)],]
                d = c(which(BLRMspecs$prov_dose1==next.dose$Var1), which(BLRMspecs$prov_dose2==next.dose$Var2))
                cat("BLRM recommended dose for de-escalation:", d, "\n")
              }
              #   if(prefer[1] != prefer[2]){ # one prefered, one low priority
              #   if(max(nn)==0 || min(pr_H0)==max(pr_H0)){ k = which.max(prefer)} # if both have no data or have equal prob, go to the preferred dose
              #   else if(min(nn)>0){ k = which.max(pr_H0)} # if both have data and not equal prob, go to higher prob
              #   else if(max(nn)>0 & min(nn)==0){
              #     if(yn[which.max(nn)] <= b.e[nn]){k = 1+round(runif(1))} # not toxic, random
              #     else if(yn[which.max(nn)] >= b.d[nn]){k = which.min(nn)} # toxic go to the other dose
              #     } # if one has data, the other has not, go to the one has no data
              # }else if(prefer[1] == prefer[2]){ # same priority
              #   if(max(nn)==0 || min(pr_H0)==max(pr_H0)){ k = 1+round(runif(1))} # if both have no data or have equal prob, random pick with equal allocation
              #   else if(min(nn)>0){ k = which.max(pr_H0)} # if both have data and not equal prob, go to higher prob
              #   else if(max(nn)>0 & min(nn)==0){ k = which.min(nn)} # if one has data, the other has not, go to the one has no data
              # }
              #
              # d = d + c(delevel[1, k], delevel[2, k])

            }
          }
        }
        else { ## stay ----------------------------------------------------------
          d = d
        }


      }
      Y[, , trial] = y
      N[, , trial] = n
      if (earlystop == 1) {
        dselect[trial, ] = c(99, 99)
      }else {
        selcomb = select.mtd.comb.boin(target, n, y,
                                       cutoff.eli, extrasafe, offset,
                                       boundMTD=boundMTD,p.tox=p.tox,mtd.contour = FALSE)$MTD
        dselect[trial, 1] = selcomb[1]
        dselect[trial, 2] = selcomb[2]
      }

      # print(n[c(1,4,5,8,9,12)])
      # print(y[c(1,4,5,8,9,12)])
    }
    selpercent = matrix(rep(0, ndose), dim(p.true)[1], dim(p.true)[2])
    nptsdose = apply(N, c(1, 2), mean, digits = 2, format = "f")
    ntoxdose = apply(Y, c(1, 2), mean, digits = 2, format = "f")
    for (i in 1:dim(p.true)[1]) for (j in 1:dim(p.true)[2]) {
      {
        selpercent[i, j] = sum(dselect[, 1] == i & dselect[,
                                                           2] == j)/ntrial * 100
      }
    }
    names_vector <- c("NO", "LowP", "Prefer")
    preferred.doses.c = matrix(names_vector[preferred.doses+2],
                               nrow = nrow(preferred.doses),
                               ncol = ncol(preferred.doses))


    if (JJ <= KK) {
      rownames(p.true) = paste("DoseA", 1:dim(p.true)[1],
                               sep = "")
      colnames(p.true) = paste("DoseB", 1:dim(p.true)[2],
                               sep = "")
      rownames(selpercent) = paste("DoseA", 1:dim(p.true)[1],
                                   sep = "")
      colnames(selpercent) = paste("DoseB", 1:dim(p.true)[2],
                                   sep = "")
      rownames(preferred.doses.c) = paste("DoseA", 1:dim(p.true)[1],
                                          sep = "")
      colnames(preferred.doses.c) = paste("DoseB", 1:dim(p.true)[2],
                                          sep = "")
      out = list(p.true = round(p.true, 2), preferred.doses = preferred.doses.c, selpercent = round(selpercent,2),
                 npatients = round(apply(N, c(1, 2), mean),2), ntox = round(apply(Y, c(1, 2), mean), 2),
                 totaltox = round(sum(Y)/ntrial, 1), totaln = round(sum(N)/ntrial,1),
                 pcs = paste(round(sum(selpercent[which(abs(p.true -target) == min(abs(p.true - target)), arr.ind = TRUE)]),1), "%", sep = ""),
                 pas = paste(round(sum(selpercent[which((p.true<=0.33 & p.true>=0.16), arr.ind = TRUE)]),1), "%"),
                 npercent = paste(round(sum(nptsdose[which(abs(p.true -target) == min(abs(p.true - target)), arr.ind = TRUE)])/sum(nptsdose) *100, 1), "%", sep = ""),
                 percentstop=100-sum(round(selpercent,2)),flowchart = FALSE)
      rownames(out$npatients) = paste("DoseA", 1:dim(p.true)[1],
                                      sep = "")
      colnames(out$npatients) = paste("DoseB", 1:dim(p.true)[2],
                                      sep = "")
      rownames(out$ntox) = paste("DoseA", 1:dim(p.true)[1],
                                 sep = "")
      colnames(out$ntox) = paste("DoseB", 1:dim(p.true)[2],
                                 sep = "")

      return(out)
    }
    else {
      colnames(p.true) = paste("DoseB", 1:dim(t(p.true))[1],
                               sep = "")
      rownames(p.true) = paste("DoseA", 1:dim(t(p.true))[2],
                               sep = "")
      colnames(preferred.doses.c) = paste("DoseB", 1:dim(t(p.true))[1],
                                          sep = "")
      rownames(preferred.doses.c) = paste("DoseA", 1:dim(t(p.true))[2],
                                          sep = "")
      colnames(selpercent) = paste("DoseB", 1:dim(t(p.true))[1],
                                   sep = "")
      rownames(selpercent) = paste("DoseA", 1:dim(t(p.true))[2],
                                   sep = "")
      colnames(npatients) = paste("DoseB", 1:dim(t(p.true))[1],
                                  sep = "")
      rownames(npatients) = paste("DoseA", 1:dim(t(p.true))[2],
                                  sep = "")
      colnames(ntox) = paste("DoseB", 1:dim(t(p.true))[1],
                             sep = "")
      rownames(ntox) = paste("DoseA", 1:dim(t(p.true))[2],
                             sep = "")
      out = list(p.true = round(t(p.true), 2), preferred.doses = preferred.doses.c,  selpercent = round(t(selpercent),2),
                 npatients = round(t(apply(N, c(1, 2), mean)), 2), ntox = round(t(apply(Y, c(1, 2), mean)),2),
                 totaltox = round(sum(Y)/ntrial, 1), totaln = round(sum(N)/ntrial,1),
                 pcs = paste(round(sum(selpercent[which(abs(p.true -target) == min(abs(p.true - target)), arr.ind = TRUE)]),
                                   1), "%"),
                 pas = paste(round(sum(selpercent[which((p.true<=0.33 & p.true>=0.16), arr.ind = TRUE)]),1), "%"),
                 npercent = paste(round(sum(nptsdose[which(abs(p.true -target) == min(abs(p.true - target)), arr.ind = TRUE)])/sum(nptsdose) *100, 1), "%"),
                 percentstop=100-sum(round(selpercent,2)),
                 flowchart = FALSE)

      return(out)
    }
  }
  select.mtd.comb.boin <- function(target, npts, ntox, cutoff.eli = 0.95,
                                   extrasafe = FALSE, offset = 0.05,
                                   boundMTD=FALSE,p.tox=1.4*target,
                                   mtd.contour = FALSE) {
    lambda_d = log((1 - target)/(1 - p.tox))/log(p.tox * (1 -target)/(target * (1 - p.tox)))
    y = ntox
    n = npts
    if (nrow(n) > ncol(n) | nrow(y) > ncol(y)) {
      stop("npts and ntox should be arranged in a way (i.e., rotated) such that for each of them, the number of rows is less than or equal to the number of columns.")
    }
    elimi = matrix(0, dim(n)[1], dim(n)[2])
    if (extrasafe) {
      if (n[1, 1] >= 3) {
        if (1 - pbeta(target, y[1, 1] + 1, n[1, 1] -
                      y[1, 1] + 1) > cutoff.eli - offset) {
          elimi[, ] = 1
        }
      }
    }
    for (i in 1:dim(n)[1]) {
      for (j in 1:dim(n)[2]) {
        if (n[i, j] >= 3) {
          if (1 - pbeta(target, y[i, j] + 1, n[i, j] -
                        y[i, j] + 1) > cutoff.eli) {
            elimi[i:dim(n)[1], j] = 1
            elimi[i, j:dim(n)[2]] = 1
            break
          }
        }
      }
    }

    selectdose=NULL
    if (elimi[1] == 1) {

      selectdose = c(99, 99)
      selectdoses = matrix(selectdose, nrow = 1)

    }else {

      phat = (y + 0.05)/(n + 0.1)
      phat = Iso::biviso(phat, n + 0.1, warn = TRUE)[,
      ]
      phat.out = phat
      phat.out[n == 0] = NA
      phat[elimi == 1] = 1.1
      phat = phat * (n != 0) + (1e-05) * (matrix(rep(1:dim(n)[1],
                                                     each = dim(n)[2], len = length(n)), dim(n)[1],
                                                 byrow = T) + matrix(rep(1:dim(n)[2], each = dim(n)[1],
                                                                         len = length(n)), dim(n)[1]))


      if(boundMTD){

        if(all(phat[n!=0]>=lambda_d)){
          selectdose = c(99, 99)


          selectdoses = matrix(selectdose, nrow = 1)
        }else{
          phat[phat>=lambda_d]=10}}

      if(is.null(selectdose)){

        phat[n == 0] = 10
        selectdose = which(abs(phat - target) == min(abs(phat -
                                                           target)), arr.ind = TRUE)
        if (length(selectdose) > 2)
          selectdose = selectdose[1, ]
        aa = function(x) as.numeric(as.character(x))
        if (mtd.contour == TRUE) {
          selectdoses = cbind(row = 1:dim(n)[1], col = rep(99,
                                                           dim(n)[1]))
          for (k in dim(n)[1]:1) {
            kn = n[k, ]
            ky = y[k, ]
            kelimi = elimi[k, ]
            kphat = phat[k, ]
            if (kelimi[1] == 1 || sum(n[kelimi == 0]) ==
                0) {
              kseldose = 99
            }
            else {
              adm.set = (kn != 0) & (kelimi == 0)
              adm.index = which(adm.set == T)
              y.adm = ky[adm.set]
              n.adm = kn[adm.set]
              selectd = sort(abs(kphat[adm.set] - target),
                             index.return = T)$ix[1]
              kseldose = adm.index[selectd]
            }
            selectdoses[k, 2] = ifelse(is.na(kseldose),
                                       99, kseldose)
            if (k < dim(n)[1])
              if (selectdoses[k + 1, 2] == dim(n)[2])
                selectdoses[k, 2] = dim(n)[2]
            if (k < dim(n)[1])
              if (aa(selectdoses[k + 1, 2]) == dim(n)[2] &
                  aa(selectdoses[k + 1, 2]) == aa(selectdoses[k,
                                                              2]))
                selectdoses[k, 2] = 99
          }
        }
        else {
          selectdoses = matrix(99, nrow = 1, ncol = 2)
          selectdoses[1, ] = matrix(selectdose, nrow = 1)
        }
        selectdoses = matrix(selectdoses[selectdoses[, 2] !=
                                           99, ], ncol = 2)
      }

      colnames(selectdoses) = c("DoseA", "DoseB")
    }
    if (mtd.contour == FALSE) {
      if (selectdoses[1, 1] == 99 && selectdoses[1, 2] ==
          99) {

        out=list(target = target, MTD = 99, p_est = matrix(NA,
                                                           nrow = dim(npts)[1], ncol = dim(npts)[2]))

        return(out)
      }
      else {
        out=list(target = target, MTD = selectdoses,
                 p_est = round(phat.out, 2))

        return(out)
      }
    }
    else {
      if (length(selectdoses) == 0) {
        out=list(target = target, MTD = 99, p_est = matrix(NA,
                                                           nrow = dim(npts)[1], ncol = dim(npts)[2]))


        return(out)

      }
      else {
        out=list(target = target, MTD = selectdoses,
                 p_est = round(phat.out, 2))

        return(out)
      }
    }
  }


  JJ = nrow(p.true)
  KK = ncol(p.true)
  if (JJ > KK) {
    stop("p.true should be arranged in a way (i.e., rotated) such that the number of rows is less than or equal to the number of columns.")

  }
  if (mtd.contour == FALSE) {
    if (is.null(n.earlystop) == TRUE)
      n.earlystop = 100
    if (n.earlystop <= 6) {
      warning("the value of n.earlystop is too low to ensure good operating characteristics. Recommend n.earlystop = 9 to 18 ")
    }
    if (length(ncohort) > 1) {
      warning("ncohort is the total number of cohorts for the trial. Please enter a scalar.")
    }
    if (((JJ * KK) <= 4) & (sum(ncohort) <= 6)) {
      warning("the sample size is too small, which may lead to poor operating characteristics. Suggest to increase the number of cohort.")
    }
    if (((JJ * KK) > 4) & (sum(ncohort) <= 8)) {
      warning("the sample size is too small, which may lead to poor operating characteristics. Suggest to increase the number of cohort.")
    }
    # Use parLapply to run in parallel
    out <- parallel::parLapply(cl, seed, fun = get.oc.comb.boin.blrm,
                               BLRMspecs=BLRMspecs, target = target, p.true = p.true,
                               ncohort = sum(ncohort), cohortsize = cohortsize,
                               preferred.doses = preferred.doses,
                               n.earlystop = n.earlystop, startdose = startdose,
                               titration = titration,
                               p.saf = p.saf, p.tox = p.tox,
                               cutoff.eli = cutoff.eli, extrasafe = extrasafe,
                               offset = offset,boundMTD=boundMTD,
                               explore_deescalation=explore_deescalation,
                               ntrial = nsim_per_cluster
    )


    class(out)<-"boin"
    return(out)
  }



}
